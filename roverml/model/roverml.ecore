import ecore : 'http://www.eclipse.org/emf/2002/Ecore' ;

package roverml : roverml = 'http://www.example.org/roverml'
{
	class System extends NamedElement
	{
		property programs : Program[*|1] { ordered composes };
		property rovers : Rover[*|1] { ordered composes };
	}
	class Rover extends NamedElement
	{
		property components : Component[*|1] { ordered composes };
		--Проверява всички елементи на ровъра и дали те имат различни имена. Прави се с цел, всяко име на компонент да е уникално:
		invariant uniqueComponentNames: self.components -> forAll(c1, c2 | c1 <> c2 implies c1.name <> c2.name);
		--Проверява всички инстанции на ровъра, дали някоя от тях е от тип мотор. Ако такъв съществува, всичко е точно. Необходимо е да има поне 1 мотор в робота:
		invariant minNumMotors: self.components -> exists(m | m.oclIsTypeOf(Motor) = true);
	}
	class Program extends NamedElement
	{
		property roverExec : Rover[?];
		property blocks : Block[?] { composes };
	}
	abstract class NamedElement
	{
		attribute name : String[1];
	}
	class Component extends NamedElement;
	class Sensor extends Component;
	class Actuator extends Component;
	class GPS extends Sensor
	{
		attribute x : ecore::EFloat[*|1] { ordered !unique };
		attribute y : ecore::EFloat[*|1] { ordered !unique };
	}
	class Compass extends Sensor
	{
		attribute angle : ecore::EInt[1];
	}
	class DistanceSensor extends Sensor
	{
		attribute distance : ecore::EDouble[1];
	}
	class Motor extends Actuator;
	class Light extends Actuator;
	class Block
	{
		property transitions : Transition[*|1] { ordered composes };
		property commands : Command[*|1] { ordered composes };
	}
	class Command
	{
		property outgoingTransitions#source : Transition[*|1] { ordered };
		property incomingTransitions#target : Transition[*|1] { ordered };
		property components : Component[*|1] { ordered };
	}
	class Transition
	{
		property source#outgoingTransitions : Command[1];
		property target#incomingTransitions : Command[1];
	}
	class SetLightColor extends Command
	{
		attribute color : Colours[1] { transient };
		--Почти всички класове наследили класа Command имат по няколко изходящи транзиции,то тогава само 1 от тях може да е регулярна, другите могат единствено да бъдат Triggered. 
		--Този ред взима всички изходящи транзиции от тип Regular в съответния клас и сравнява броят им. Броят им трябва да е по-малък или равен на 1:
		invariant regularTransCount: self.outgoingTransitions -> select(m | m.oclIsTypeOf(Regular) = true) -> size() <= 1;
	}
	class Wait extends Command
	{
		attribute time : ecore::EInt[1];
		property timeUnit : Time[1] { composes };
		--Както е описано в условието, когато работим с време, то никога не трябва да е с отрицателна стойност. 
		--Понеже ползваме време само в клас Wait, то там проверяваме атрибута Time дали е по-голям или равен на 0:
		invariant timeNotNegative: self.time >= 0;
		--Почти всички класове наследили класа Command имат по няколко изходящи транзиции,то тогава само 1 от тях може да е регулярна, другите могат единствено да бъдат Triggered. 
		--Този ред взима всички изходящи транзиции от тип Regular в съответния клас и сравнява броят им. Броят им трябва да е по-малък или равен на 1:
		invariant regularTransCount: self.outgoingTransitions -> select(m | m.oclIsTypeOf(Regular) = true) -> size() <= 1;
	}
	class Move extends Command
	{
		attribute length : ecore::EDouble[1];
		attribute velocity : ecore::EDouble[1];
		property velocityUnits : Velocity[1] { composes };
		property lengthUnits : Length[1] { composes };
		--Тук, подобно на предходния констрейнт, скоростта трябва да е различна от 0. Нея я ползваме само в класа Move, атрибута Velocity. 
		--Съответно проверяваме дали е различен от 0:
		invariant velocityNotZero: self.velocity <> 0;
		--Тук целта е, ако на командата Move не е зададена дължина(дължината по подразбиране 0.0), то следващата транзиция може да бъде единствено Triggered. 
		--Използваме If зада проверим първо, дали атрибута Length е нула и дали всички outgoingTransitions са от вид(Kind) Triggered. 
		--Ако това е така, връщаме True(всичко е точно). В противен случай, проверяваме дали случайно не е пук зададена някаква дължина и пак връщаме True. Във всички останали случаи, връщаме False:
		invariant
		indefinitelyTrigg: if length = 0.0 and self.outgoingTransitions -> forAll(m | m.oclIsKindOf(Triggered) = true) then true elseif length <> 0.0 then true else false endif;
		--Почти всички класове наследили класа Command имат по няколко изходящи транзиции,то тогава само 1 от тях може да е регулярна, другите могат единствено да бъдат Triggered. 
		--Този ред взима всички изходящи транзиции от тип Regular в съответния клас и сравнява броят им. Броят им трябва да е по-малък или равен на 1:
		invariant regularTransCount: self.outgoingTransitions -> select(m | m.oclIsTypeOf(Regular) = true) -> size() <= 1;
	}
	class Rotate extends Command
	{
		attribute angle : ecore::EInt[1];
		property angleUnits : Angle[1] { composes };
		--Почти всички класове наследили класа Command имат по няколко изходящи транзиции,то тогава само 1 от тях може да е регулярна, другите могат единствено да бъдат Triggered. 
		--Този ред взима всички изходящи транзиции от тип Regular в съответния клас и сравнява броят им. Броят им трябва да е по-малък или равен на 1:
		invariant regularTransCount: self.outgoingTransitions -> select(m | m.oclIsTypeOf(Regular) = true) -> size() <= 1;
	}
	class Terminate extends Command
	{
		--От класа Terminate не бива да има никакви изходящи транзиции. 
		--Кода проверява изично, че outgoingTransitions не съществуват:
		invariant noOutTransitions: self.outgoingTransitions -> isEmpty();
	}
	class Repeat extends Command
	{
		attribute numberOfReps : ecore::EInt[1];
		property commands : Command[*|1] { ordered composes };
		--Когато в класа Repeat стойността на атрибута numberOfReps е равна на -1, то тогава командата Repeat трябва да се повтаря до безкрайност.
		--За целта ползваме If. Първо проверяваме дали numberOfReps е равен на -1 и дали в същото време от този клас има outgoingTransitions със зададена цел отново команда Repeat.
		--Ако това е така, всичко е точно. Ако ли не, то проверяваме дали пък numberOfReps не е равен на нещо различно от -1. Тогава също всичко е точно. Във всички други случаи, имаме проблем:
		invariant indefRepeats: if self.numberOfReps = -1 and self.outgoingTransitions -> select(t: Transition | t.source -> exists(m | m.oclIsTypeOf(Repeat) = true)) -> notEmpty() then true elseif 
		self.numberOfReps <> -1 then true else false endif;
		--Почти всички класове наследили класа Command имат по няколко изходящи транзиции,то тогава само 1 от тях може да е регулярна, другите могат единствено да бъдат Triggered. 
		--Този ред взима всички изходящи транзиции от тип Regular в съответния клас и сравнява броят им. Броят им трябва да е по-малък или равен на 1:
		invariant regularTransCount: self.outgoingTransitions -> select(m | m.oclIsTypeOf(Regular) = true) -> size() <= 1;
	}
	class Triggered extends Transition
	{
		attribute operator : ecore::EChar[?];
	}
	class Regular extends Transition;
	class DistanceSensorTrigger extends Triggered
	{
		property length : Length[?];
		attribute dist : ecore::EDouble[1];
		property distancesensor : DistanceSensor[?];
	}
	class CompassTrigger extends Triggered
	{
		property angles : Angle[?];
		attribute angle : ecore::EInt[1];
		property compass : Compass[?];
	}
	class GPSTrigger extends Triggered
	{
		property position : Position[?];
		attribute x : ecore::EFloat[1];
		attribute y : ecore::EFloat[1];
		property gps : GPS[?];
	}
	class Quantity;
	class SingleQuantity extends Quantity;
	class Position extends Quantity
	{
		attribute x : ecore::EFloat[1];
		attribute y : ecore::EFloat[1];
	}
	class Time extends SingleQuantity
	{
		attribute units : TimeUnits[1] { transient };
	}
	enum TimeUnits
	{
		literal NANOSECONDS;
		literal MILLISECONDS;
		literal SECONDS;
		literal MINUTES;
		literal HOURS;
	}
	class Velocity extends SingleQuantity
	{
		attribute units : VelocityUnits[1] { transient };
	}
	enum VelocityUnits
	{
		literal MILLIMETERS_PER_SECOND;
		literal CENTIMETERS_PER_SECOND;
	}
	class Length extends SingleQuantity
	{
		attribute units : LengthUnits[1] { transient };
	}
	enum LengthUnits
	{
		literal MILLIMETERS;
		literal CENTIMETERS;
		literal METERS;
	}
	class Angle extends SingleQuantity
	{
		attribute units : AngleUnits[1] { transient };
	}
	enum AngleUnits
	{
		literal RADIANS;
		literal DEGREES;
	}
	enum Colours
	{
		literal NONE;
		literal RED;
		literal GREEN;
		literal BLUE;
		literal YELLOW;
	}
}