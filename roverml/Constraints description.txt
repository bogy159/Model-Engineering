Описание на констрейнтс:

1.Проверява всички елементи на ровъра и дали те имат различни имена. Прави се с цел, всяко име на компонент да е уникално:
invariant uniqueComponentNames: self.components -> forAll(c1, c2 | c1 <> c2 implies c1.name <> c2.name);

2.Проверява всички инстанции на ровъра, дали някоя от тях е от тип мотор. Ако такъв съществува, всичко е точно. Необходимо е да има поне 1 мотор в робота:
invariant minNumMotors: self.components -> exists(m | m.oclIsTypeOf(Motor) = true);

3.Почти всички класове наследили класа Command имат по няколко изходящи транзиции,то тогава само 1 от тях може да е регулярна, другите могат единствено да бъдат Triggered. 
Този ред взима всички изходящи транзиции от тип Regular в съответния клас и сравнява броят им. Броят им трябва да е по-малък или равен на 1:
invariant regularTransCount: self.outgoingTransitions -> select(m | m.oclIsTypeOf(Regular) = true) -> size() <= 1;

4.Както е описано в условието, когато работим с време, то никога не трябва да е с отрицателна стойност. 
Понеже ползваме време само в клас Wait, то там проверяваме атрибута Time дали е по-голям или равен на 0:
invariant timeNotNegative: self.time >= 0;

5.Тук, подобно на предходния констрейнт, скоростта трябва да е различна от 0. Нея я ползваме само в класа Move, атрибута Velocity. 
Съответно проверяваме дали е различен от 0:
invariant velocityNotZero: self.velocity <> 0;

6.Тук целта е, ако на командата Move не е зададена дължина(дължината по подразбиране 0.0), то следващата транзиция може да бъде единствено Triggered. 
Използваме If зада проверим първо, дали атрибута Length е нула и дали всички outgoingTransitions са от вид(Kind) Triggered. 
Ако това е така, връщаме True(всичко е точно). В противен случай, проверяваме дали случайно не е пук зададена някаква дължина и пак връщаме True. Във всички останали случаи, връщаме False:
invariant indefinitelyTrigg: if length = 0.0 and self.outgoingTransitions -> forAll(m | m.oclIsKindOf(Triggered) = true) then true elseif length <> 0.0 then true else false endif;

7.От класа Terminate не бива да има никакви изходящи транзиции. 
Кода проверява изично, че outgoingTransitions не съществуват:
invariant noOutTransitions: self.outgoingTransitions -> isEmpty();

8.Когато в класа Repeat стойността на атрибута numberOfReps е равна на -1, то тогава командата Repeat трябва да се повтаря до безкрайност.
За целта ползваме If. Първо проверяваме дали numberOfReps е равен на -1 и дали в същото време от този клас има outgoingTransitions със зададена цел отново команда Repeat.
Ако това е така, всичко е точно. Ако ли не, то проверяваме дали пък numberOfReps не е равен на нещо различно от -1. Тогава също всичко е точно. Във всички други случаи, имаме проблем.
invariant indefRepeats: if self.numberOfReps = -1 and self.outgoingTransitions -> select(t: Transition | t.source -> exists(m | m.oclIsTypeOf(Repeat) = true)) -> notEmpty() then true elseif self.numberOfReps <> -1 then true else false endif;

Забележка: Не ми харесва, че не забранихме никъде Rotate да се изпулнява 2 пъти поред.
Също не ми харесва констрейнт номер 8. Той залага на това, че всеки път, когато стойността е -1, то трябва да има някаква си изрично създадена транзиция от Repeat до Repeat. Тук ще имаме проблеми.